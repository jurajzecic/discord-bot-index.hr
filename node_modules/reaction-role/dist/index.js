"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactionRole = void 0;
const discord_js_1 = require("discord.js");
const bookman_1 = require("bookman");
class ReactionRole extends discord_js_1.Client {
    constructor(token, mongodb_uri) {
        super();
        this.ready = false;
        this._token = token;
        let adapter;
        if (mongodb_uri)
            adapter = new bookman_1.adapters.MongoDB({
                databaseName: "RR",
                defaultDir: "ReactionRole",
                mongodbURL: mongodb_uri,
            });
        else
            adapter = new bookman_1.adapters.FS({
                databaseName: "RR",
                defaultDir: "ReactionRole",
            });
        this.database = new bookman_1.Database(adapter);
    }
    createOption(emoji, addMessage, removeMessage, roles) {
        return {
            emoji,
            addMessage,
            removeMessage,
            roles,
        };
    }
    createMessage(messageID, channelID, limit, restrictions, ...reactions) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = {
                messageID,
                channelID,
                limit,
                restrictions,
                reactions,
            };
            yield this.database.set(messageID, data);
            return data;
        });
    }
    deleteMessage(messageID) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.database.delete(messageID);
            return this.exportConfig();
        });
    }
    importConfig(config) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const data in config) {
                const messageData = config[data];
                yield this.database.set(messageData.messageID, messageData);
            }
            return this.exportConfig();
        });
    }
    exportConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (yield this.database.fetchAll());
            return data;
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            console.info("[ReactionRole] Spawned.");
            this.on("ready", () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                let messages = yield this.exportConfig();
                console.info(`[ReactionRole] Fetching ${Object.keys(messages).length} messages.`);
                for (const messageID in messages) {
                    const messageData = messages[messageID];
                    const channel = this.channels.cache.get(messageData.channelID);
                    if (!channel) {
                        this.database.delete(messageID);
                        continue;
                    }
                    const guild = channel.guild;
                    if (!guild) {
                        this.database.delete(messageID);
                        continue;
                    }
                    const message = yield channel.messages
                        .fetch(messageID)
                        .catch(() => {
                        this.database.delete(messageID);
                    });
                    if (!message)
                        continue;
                    for (let i = 0; i < messageData.reactions.length; i++) {
                        const option = messageData.reactions[i];
                        const newAddRoles = [];
                        for (const role of option.roles) {
                            if (guild.roles.cache.has(role))
                                newAddRoles.push(role);
                        }
                        let updated = false;
                        if (option.roles.length != newAddRoles.length) {
                            option.roles = newAddRoles;
                            updated = true;
                        }
                        if (updated) {
                            messageData.reactions[i].roles = newAddRoles;
                            this.database.set(`${messageID}.reactions`, messageData.reactions);
                        }
                        if (!message.reactions.cache.has(option.emoji))
                            yield message.react(option.emoji);
                    }
                }
                messages = yield this.exportConfig();
                console.info(`[ReactionRole] Fetched ${Object.keys(messages).length} messages.`);
                console.info(`[ReactionRole] Ready and logged in as ${(_a = this.user) === null || _a === void 0 ? void 0 : _a.tag} (${(_b = this.user) === null || _b === void 0 ? void 0 : _b.id})`);
                this.ready = true;
            })).on("raw", (packet) => __awaiter(this, void 0, void 0, function* () {
                if (!this.ready ||
                    (packet.t != "MESSAGE_REACTION_ADD" &&
                        packet.t != "MESSAGE_REACTION_REMOVE"))
                    return;
                const messageData = (yield this.database.get(packet.d.message_id));
                if (!messageData)
                    return;
                const guild = this.guilds.cache.get(packet.d.guild_id);
                if (!guild)
                    return;
                for (const option of messageData.reactions) {
                    for (const id of option.roles) {
                        const role = guild.roles.cache.get(id);
                        if (!role)
                            return;
                    }
                }
                const member = guild.members.cache.get(packet.d.user_id) ||
                    (yield guild.members.fetch(packet.d.user_id));
                if (!member)
                    return;
                if (messageData.restrictions &&
                    !member.permissions.has(messageData.restrictions))
                    return;
                const channel = guild.channels.cache.get(packet.d.channel_id);
                if (!channel)
                    return;
                const message = channel.messages.cache.get(packet.d.message_id) ||
                    (yield channel.messages.fetch(packet.d.message_id));
                if (!message)
                    return;
                const option = messageData.reactions.find((o) => o.emoji === packet.d.emoji.name ||
                    o.emoji === packet.d.emoji.id);
                if (!option)
                    return;
                const reaction = message.reactions.cache.get(option.emoji);
                if (!reaction)
                    yield message.react(option.emoji);
                if (packet.t === "MESSAGE_REACTION_ADD") {
                    let userReactions = 0;
                    for (const r of message.reactions.cache.array()) {
                        const users = yield r.users.fetch();
                        if (users.has(member.id))
                            userReactions++;
                    }
                    if (userReactions > messageData.limit)
                        return;
                    yield member.roles.add(option.roles);
                    if (option.addMessage)
                        yield member.send(option.addMessage).catch(() => undefined);
                }
                else {
                    yield member.roles.remove(option.roles);
                    if (option.removeMessage)
                        yield member
                            .send(option.removeMessage)
                            .catch(() => undefined);
                }
            }));
            return this.login(this._token);
        });
    }
    reInit() {
        return __awaiter(this, void 0, void 0, function* () {
            this.destroy();
            const system = new ReactionRole(this._token);
            yield system.init();
            return system;
        });
    }
}
exports.ReactionRole = ReactionRole;
