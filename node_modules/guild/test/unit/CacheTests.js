var expect = require('chai').expect;
var Cache = require('../../lib/Cache');

describe('Cache', function () {

    describe('Init with a size of 200', function () {

        beforeEach(function () {

            this.cache = new Cache(200);

        });

        it('Should not be null', function () {

            expect(this.cache).to.not.equal(undefined);

        });

        describe('Adding items to the cache within the bounds of its size (5 items)', function () {

            beforeEach(function () {

                this.cache.put('testA', {object: 'testA'});
                this.cache.put('testB', {object: 'testB'});
                this.cache.put('testC', {object: 'testC'});
                this.cache.put('testD', {object: 'testD'});
                this.cache.put('testE', {object: 'testE'});

            });

            it('Should return the items when asked', function () {

                expect(this.cache.get('testA')).to.deep.equal({object: 'testA'});
                expect(this.cache.get('testB')).to.deep.equal({object: 'testB'});
                expect(this.cache.get('testC')).to.deep.equal({object: 'testC'});
                expect(this.cache.get('testD')).to.deep.equal({object: 'testD'});
                expect(this.cache.get('testE')).to.deep.equal({object: 'testE'});

            });

            it('Should indicate the correct current size (5)', function () {

                expect(this.cache.currentSize()).to.equal(5);

            });

            it('Should not return anything that wasn\'nt added', function () {

                expect(this.cache.get('testF')).to.deep.equal(undefined);

            });

        });

        describe('Adding an item with a key that already exists in the cache', function () {

            beforeEach(function () {

                this.cache.put('testA', {object: 'testA'});
                this.cache.put('testA', {object: 'testA-Version2'});

            });

            it('Should return most recent version of the item', function () {

                expect(this.cache.get('testA')).to.deep.equal({object: 'testA-Version2'});

            });

            it('Should indicate the correct current size', function () {

                expect(this.cache.currentSize()).to.equal(1);

            });

        });

        describe('Adding items to the cache that reach the bounds exactly (200 items)', function () {

            beforeEach(function () {

                for (var i = 0; i < 200; i++) {
                    this.cache.put('key' + i, 'object' + i);
                }

            });

            it('Should indicate the correct current size (200)', function () {

                expect(this.cache.currentSize()).to.equal(200);

            });

            it('Should return the items when asked', function () {

                for (var i = 0; i < 200; i++) {
                    expect(this.cache.get('key' + i)).to.equal('object' + i);
                }

            });

        });

        describe('Adding items to the cache that exceed the bounds by 1 (201 items)', function () {

            beforeEach(function () {

                for (var i = 0; i < 201; i++) {
                    this.cache.put('key' + i, 'object' + i);
                }

            });

            it('Should cause an eviction, and evict a number of items (should be more than one item evicted, but indeterminate - may be zero, but not likely)', function () {

                expect((this.cache.currentSize() < 200)).to.be.true;
                expect((this.cache.currentSize() > 150)).to.be.true;

            });

            describe('Adding items after an eviction to reach the cache size bounds exactly (so that the cache is expected to contain 200 items)', function () {

                beforeEach(function () {

                    this.previousSize = this.cache.currentSize();

                    for (var i = this.previousSize; i < 200; i++) {
                        this.cache.put('new-object-key' + i, 'object' + i);
                    }

                });

                it('The cache should contain 200 items', function () {

                    expect(this.cache.currentSize()).to.equal(200);

                });

                it('Should return the new items', function () {

                    for (var i = this.previousSize; i < 200; i++) {
                        expect(this.cache.get('new-object-key' + i)).to.equal('object' + i);
                    }

                });

            });

        });

        describe('Resetting the cache', function () {

            beforeEach(function () {

                this.cache.put('testA', {object: 'testA'});
                this.cache.put('testB', {object: 'testB'});
                this.cache.put('testC', {object: 'testC'});
                this.cache.put('testD', {object: 'testD'});
                this.cache.put('testE', {object: 'testE'});

                this.cache.get('testA');
                this.cache.get('testA');
                this.cache.get('testA');

                expect(this.cache._maxCacheSize).to.equal(200);
                expect(this.cache._currentCacheSize).to.equal(5);
                expect(this.cache._largestCacheHit).to.equal(4);
                expect(this.cache._cachedObjectContainers.length).to.equal(5);
                expect(this.cache._cacheKeyToIndexMap).to.deep.equal({ testA: 0, testB: 1, testC: 2, testD: 3, testE: 4 });

                this.cache.reset();

            });

            it('Should have the correct max cache size (200)', function () {

                expect(this.cache._maxCacheSize).to.equal(200);

            });

            it('Should have a current cache size of zero', function () {

                expect(this.cache._currentCacheSize).to.equal(0);

            });

            it('Should have the correct largest cache hit', function () {

                expect(this.cache._largestCacheHit).to.equal(1);

            });

            it('Should have no cached object containers', function () {

                expect(this.cache._cachedObjectContainers.length).to.equal(0);

            });

            it('Should have an empty cache keys index', function () {

                expect(this.cache._cacheKeyToIndexMap).to.deep.equal({});

            });

        });

        describe('Removing objects', function () {


            beforeEach(function () {

                this.cache.put('testA', {object: 'testA'});
                this.cache.put('testB', {object: 'testB'});
                this.cache.put('testC', {object: 'testC'});
                this.cache.put('testD', {object: 'testD'});
                this.cache.put('testE', {object: 'testE'});

                for (var i = 0; i < 100; i++) {
                    this.cache.get('testA');
                }

                for (var i = 0; i < 50; i++) {
                    this.cache.get('testB');
                }

                for (var i = 0; i < 25; i++) {
                    this.cache.get('testC');
                }

                expect(this.cache._maxCacheSize).to.equal(200);
                expect(this.cache._currentCacheSize).to.equal(5);
                expect(this.cache._largestCacheHit).to.equal(101);
                expect(this.cache._cachedObjectContainers.length).to.equal(5);
                expect(this.cache._cacheKeyToIndexMap).to.deep.equal({ testA: 0, testB: 1, testC: 2, testD: 3, testE: 4 });

                this.cache.remove('testA');

            });

            it('Should have the correct max cache size (200)', function () {

                expect(this.cache._maxCacheSize).to.equal(200);

            });

            it('Should have the correct current cache size', function () {

                expect(this.cache._currentCacheSize).to.equal(4);

            });

            it('Should have the correct largest cache hit', function () {

                expect(this.cache._largestCacheHit).to.equal(51);

            });

            it('Should have the correct number of object containers', function () {

                expect(this.cache._cachedObjectContainers.length).to.equal(4);

            });

            it('Should have a the correct cache keys index', function () {

                expect(this.cache._cacheKeyToIndexMap).to.deep.equal({
                    "testB": 0,
                    "testC": 1,
                    "testD": 2,
                    "testE": 3
                });

            });

        });

    });

});
