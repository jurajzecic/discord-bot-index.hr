"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Job_1 = require("./Job");
const Display_1 = require("./Display");
const util = require("./util");
const Worker_1 = require("./Worker");
const builtInConcurrency = require("./concurrency/builtInConcurrency");
const Queue_1 = require("./Queue");
const SystemMonitor_1 = require("./SystemMonitor");
const events_1 = require("events");
const debug = util.debugGenerator('Cluster');
const DEFAULT_OPTIONS = {
    concurrency: 2,
    maxConcurrency: 1,
    workerCreationDelay: 0,
    puppeteerOptions: {
    // headless: false, // just for testing...
    },
    perBrowserOptions: undefined,
    monitor: false,
    timeout: 30 * 1000,
    retryLimit: 0,
    retryDelay: 0,
    skipDuplicateUrls: false,
    sameDomainDelay: 0,
    puppeteer: undefined,
};
const MONITORING_DISPLAY_INTERVAL = 500;
const CHECK_FOR_WORK_INTERVAL = 100;
const WORK_CALL_INTERVAL_LIMIT = 10;
let Cluster = /** @class */ (() => {
    class Cluster extends events_1.EventEmitter {
        constructor(options) {
            super();
            this.perBrowserOptions = null;
            this.workers = [];
            this.workersAvail = [];
            this.workersBusy = [];
            this.workersStarting = 0;
            this.allTargetCount = 0;
            this.jobQueue = new Queue_1.default();
            this.errorCount = 0;
            this.taskFunction = null;
            this.idleResolvers = [];
            this.waitForOneResolvers = [];
            this.browser = null;
            this.isClosed = false;
            this.startTime = Date.now();
            this.nextWorkerId = -1;
            this.monitoringInterval = null;
            this.display = null;
            this.duplicateCheckUrls = new Set();
            this.lastDomainAccesses = new Map();
            this.systemMonitor = new SystemMonitor_1.default();
            this.checkForWorkInterval = null;
            this.nextWorkCall = 0;
            this.workCallTimeout = null;
            this.lastLaunchedWorkerTime = 0;
            this.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
            if (this.options.monitor) {
                this.monitoringInterval = setInterval(() => this.monitor(), MONITORING_DISPLAY_INTERVAL);
            }
        }
        static launch(options) {
            return __awaiter(this, void 0, void 0, function* () {
                debug('Launching');
                const cluster = new Cluster(options);
                yield cluster.init();
                return cluster;
            });
        }
        init() {
            return __awaiter(this, void 0, void 0, function* () {
                const browserOptions = this.options.puppeteerOptions;
                let puppeteer = this.options.puppeteer;
                if (this.options.puppeteer == null) { // check for null or undefined
                    puppeteer = require('puppeteer');
                }
                else {
                    debug('Using provided (custom) puppteer object.');
                }
                if (this.options.concurrency === Cluster.CONCURRENCY_PAGE) {
                    this.browser = new builtInConcurrency.Page(browserOptions, puppeteer);
                }
                else if (this.options.concurrency === Cluster.CONCURRENCY_CONTEXT) {
                    this.browser = new builtInConcurrency.Context(browserOptions, puppeteer);
                }
                else if (this.options.concurrency === Cluster.CONCURRENCY_BROWSER) {
                    this.browser = new builtInConcurrency.Browser(browserOptions, puppeteer);
                }
                else if (typeof this.options.concurrency === 'function') {
                    this.browser = new this.options.concurrency(browserOptions, puppeteer);
                }
                else {
                    throw new Error(`Unknown concurrency option: ${this.options.concurrency}`);
                }
                if (typeof this.options.maxConcurrency !== 'number') {
                    throw new Error('maxConcurrency must be of number type');
                }
                if (this.options.perBrowserOptions
                    && this.options.perBrowserOptions.length !== this.options.maxConcurrency) {
                    throw new Error('perBrowserOptions length must equal maxConcurrency');
                }
                if (this.options.perBrowserOptions) {
                    this.perBrowserOptions = [...this.options.perBrowserOptions];
                }
                try {
                    yield this.browser.init();
                }
                catch (err) {
                    throw new Error(`Unable to launch browser, error message: ${err.message}`);
                }
                if (this.options.monitor) {
                    yield this.systemMonitor.init();
                }
                // needed in case resources are getting free (like CPU/memory) to check if
                // can launch workers
                this.checkForWorkInterval = setInterval(() => this.work(), CHECK_FOR_WORK_INTERVAL);
            });
        }
        launchWorker() {
            return __awaiter(this, void 0, void 0, function* () {
                // signal, that we are starting a worker
                this.workersStarting += 1;
                this.nextWorkerId += 1;
                this.lastLaunchedWorkerTime = Date.now();
                let nextWorkerOption;
                if (this.perBrowserOptions && this.perBrowserOptions.length > 0) {
                    nextWorkerOption = this.perBrowserOptions.shift();
                }
                const workerId = this.nextWorkerId;
                let workerBrowserInstance;
                try {
                    workerBrowserInstance = yield this.browser
                        .workerInstance(nextWorkerOption);
                }
                catch (err) {
                    throw new Error(`Unable to launch browser for worker, error message: ${err.message}`);
                }
                const worker = new Worker_1.default({
                    cluster: this,
                    args: [''],
                    browser: workerBrowserInstance,
                    id: workerId,
                });
                this.workersStarting -= 1;
                if (this.isClosed) {
                    // cluster was closed while we created a new worker (should rarely happen)
                    worker.close();
                }
                else {
                    this.workersAvail.push(worker);
                    this.workers.push(worker);
                }
            });
        }
        task(taskFunction) {
            return __awaiter(this, void 0, void 0, function* () {
                this.taskFunction = taskFunction;
            });
        }
        // check for new work soon (wait if there will be put more data into the queue, first)
        work() {
            return __awaiter(this, void 0, void 0, function* () {
                // make sure, we only call work once every WORK_CALL_INTERVAL_LIMIT (currently: 10ms)
                if (this.workCallTimeout === null) {
                    const now = Date.now();
                    // calculate when the next work call should happen
                    this.nextWorkCall = Math.max(this.nextWorkCall + WORK_CALL_INTERVAL_LIMIT, now);
                    const timeUntilNextWorkCall = this.nextWorkCall - now;
                    this.workCallTimeout = setTimeout(() => {
                        this.workCallTimeout = null;
                        this.doWork();
                    }, timeUntilNextWorkCall);
                }
            });
        }
        doWork() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.jobQueue.size() === 0) { // no jobs available
                    if (this.workersBusy.length === 0) {
                        this.idleResolvers.forEach(resolve => resolve());
                    }
                    return;
                }
                if (this.workersAvail.length === 0) { // no workers available
                    if (this.allowedToStartWorker()) {
                        yield this.launchWorker();
                        this.work();
                    }
                    return;
                }
                const job = this.jobQueue.shift();
                if (job === undefined) {
                    // skip, there are items in the queue but they are all delayed
                    return;
                }
                const url = job.getUrl();
                const domain = job.getDomain();
                // Check if URL was already crawled (on skipDuplicateUrls)
                if (this.options.skipDuplicateUrls
                    && url !== undefined && this.duplicateCheckUrls.has(url)) {
                    // already crawled, just ignore
                    debug(`Skipping duplicate URL: ${job.getUrl()}`);
                    this.work();
                    return;
                }
                // Check if the job needs to be delayed due to sameDomainDelay
                if (this.options.sameDomainDelay !== 0 && domain !== undefined) {
                    const lastDomainAccess = this.lastDomainAccesses.get(domain);
                    if (lastDomainAccess !== undefined
                        && lastDomainAccess + this.options.sameDomainDelay > Date.now()) {
                        this.jobQueue.push(job, {
                            delayUntil: lastDomainAccess + this.options.sameDomainDelay,
                        });
                        this.work();
                        return;
                    }
                }
                // Check are all positive, let's actually run the job
                if (this.options.skipDuplicateUrls && url !== undefined) {
                    this.duplicateCheckUrls.add(url);
                }
                if (this.options.sameDomainDelay !== 0 && domain !== undefined) {
                    this.lastDomainAccesses.set(domain, Date.now());
                }
                const worker = this.workersAvail.shift();
                this.workersBusy.push(worker);
                if (this.workersAvail.length !== 0 || this.allowedToStartWorker()) {
                    // we can execute more work in parallel
                    this.work();
                }
                let jobFunction;
                if (job.taskFunction !== undefined) {
                    jobFunction = job.taskFunction;
                }
                else if (this.taskFunction !== null) {
                    jobFunction = this.taskFunction;
                }
                else {
                    throw new Error('No task function defined!');
                }
                const result = yield worker.handle(jobFunction, job, this.options.timeout);
                if (result.type === 'error') {
                    if (job.executeCallbacks) {
                        job.executeCallbacks.reject(result.error);
                        this.errorCount += 1;
                    }
                    else { // ignore retryLimits in case of executeCallbacks
                        job.addError(result.error);
                        const jobWillRetry = job.tries <= this.options.retryLimit;
                        this.emit('taskerror', result.error, job.data, jobWillRetry);
                        if (jobWillRetry) {
                            let delayUntil = undefined;
                            if (this.options.retryDelay !== 0) {
                                delayUntil = Date.now() + this.options.retryDelay;
                            }
                            this.jobQueue.push(job, {
                                delayUntil,
                            });
                        }
                        else {
                            this.errorCount += 1;
                        }
                    }
                }
                else if (result.type === 'success' && job.executeCallbacks) {
                    job.executeCallbacks.resolve(result.data);
                }
                this.waitForOneResolvers.forEach(resolve => resolve(job.data));
                this.waitForOneResolvers = [];
                // add worker to available workers again
                const workerIndex = this.workersBusy.indexOf(worker);
                this.workersBusy.splice(workerIndex, 1);
                this.workersAvail.push(worker);
                this.work();
            });
        }
        allowedToStartWorker() {
            const workerCount = this.workers.length + this.workersStarting;
            return (
            // option: maxConcurrency
            (this.options.maxConcurrency === 0
                || workerCount < this.options.maxConcurrency)
                // just allow worker creaton every few milliseconds
                && (this.options.workerCreationDelay === 0
                    || this.lastLaunchedWorkerTime + this.options.workerCreationDelay < Date.now()));
        }
        // Type Guard for TypeScript
        isTaskFunction(data) {
            return (typeof data === 'function');
        }
        queueJob(data, taskFunction, callbacks) {
            let realData;
            let realFunction;
            if (this.isTaskFunction(data)) {
                realFunction = data;
            }
            else {
                realData = data;
                realFunction = taskFunction;
            }
            const job = new Job_1.default(realData, realFunction, callbacks);
            this.allTargetCount += 1;
            this.jobQueue.push(job);
            this.emit('queue', realData, realFunction);
            this.work();
        }
        queue(data, taskFunction) {
            return __awaiter(this, void 0, void 0, function* () {
                this.queueJob(data, taskFunction);
            });
        }
        execute(data, taskFunction) {
            return new Promise((resolve, reject) => {
                const callbacks = { resolve, reject };
                this.queueJob(data, taskFunction, callbacks);
            });
        }
        idle() {
            return new Promise(resolve => this.idleResolvers.push(resolve));
        }
        waitForOne() {
            return new Promise(resolve => this.waitForOneResolvers.push(resolve));
        }
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                this.isClosed = true;
                clearInterval(this.checkForWorkInterval);
                clearTimeout(this.workCallTimeout);
                // close workers
                yield Promise.all(this.workers.map(worker => worker.close()));
                try {
                    yield this.browser.close();
                }
                catch (err) {
                    debug(`Error: Unable to close browser, message: ${err.message}`);
                }
                if (this.monitoringInterval) {
                    this.monitor();
                    clearInterval(this.monitoringInterval);
                }
                if (this.display) {
                    this.display.close();
                }
                this.systemMonitor.close();
                debug('Closed');
            });
        }
        monitor() {
            if (!this.display) {
                this.display = new Display_1.default();
            }
            const display = this.display;
            const now = Date.now();
            const timeDiff = now - this.startTime;
            const doneTargets = this.allTargetCount - this.jobQueue.size() - this.workersBusy.length;
            const donePercentage = this.allTargetCount === 0
                ? 1 : (doneTargets / this.allTargetCount);
            const donePercStr = (100 * donePercentage).toFixed(2);
            const errorPerc = doneTargets === 0 ?
                '0.00' : (100 * this.errorCount / doneTargets).toFixed(2);
            const timeRunning = util.formatDuration(timeDiff);
            let timeRemainingMillis = -1;
            if (donePercentage !== 0) {
                timeRemainingMillis = ((timeDiff) / donePercentage) - timeDiff;
            }
            const timeRemining = util.formatDuration(timeRemainingMillis);
            const cpuUsage = this.systemMonitor.getCpuUsage().toFixed(1);
            const memoryUsage = this.systemMonitor.getMemoryUsage().toFixed(1);
            const pagesPerSecond = doneTargets === 0 ?
                '0' : (doneTargets * 1000 / timeDiff).toFixed(2);
            display.log(`== Start:     ${util.formatDateTime(this.startTime)}`);
            display.log(`== Now:       ${util.formatDateTime(now)} (running for ${timeRunning})`);
            display.log(`== Progress:  ${doneTargets} / ${this.allTargetCount} (${donePercStr}%)`
                + `, errors: ${this.errorCount} (${errorPerc}%)`);
            display.log(`== Remaining: ${timeRemining} (@ ${pagesPerSecond} pages/second)`);
            display.log(`== Sys. load: ${cpuUsage}% CPU / ${memoryUsage}% memory`);
            display.log(`== Workers:   ${this.workers.length + this.workersStarting}`);
            this.workers.forEach((worker, i) => {
                const isIdle = this.workersAvail.indexOf(worker) !== -1;
                let workOrIdle;
                let workerUrl = '';
                if (isIdle) {
                    workOrIdle = 'IDLE';
                }
                else {
                    workOrIdle = 'WORK';
                    if (worker.activeTarget) {
                        workerUrl = worker.activeTarget.getUrl() || 'UNKNOWN TARGET';
                    }
                    else {
                        workerUrl = 'NO TARGET (should not be happening)';
                    }
                }
                display.log(`   #${i} ${workOrIdle} ${workerUrl}`);
            });
            for (let i = 0; i < this.workersStarting; i += 1) {
                display.log(`   #${this.workers.length + i} STARTING...`);
            }
            display.resetCursor();
        }
    }
    Cluster.CONCURRENCY_PAGE = 1; // shares cookies, etc.
    Cluster.CONCURRENCY_CONTEXT = 2; // no cookie sharing (uses contexts)
    Cluster.CONCURRENCY_BROWSER = 3; // no cookie sharing and individual processes (uses contexts)
    return Cluster;
})();
exports.default = Cluster;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2x1c3Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9DbHVzdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQ0EsK0JBQTZFO0FBQzdFLHVDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IscUNBQThDO0FBRTlDLHVFQUF1RTtBQUd2RSxtQ0FBNEI7QUFDNUIsbURBQTRDO0FBQzVDLG1DQUFzQztBQUl0QyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBdUI3QyxNQUFNLGVBQWUsR0FBbUI7SUFDcEMsV0FBVyxFQUFFLENBQUM7SUFDZCxjQUFjLEVBQUUsQ0FBQztJQUNqQixtQkFBbUIsRUFBRSxDQUFDO0lBQ3RCLGdCQUFnQixFQUFFO0lBQ2QsMENBQTBDO0tBQzdDO0lBQ0QsaUJBQWlCLEVBQUUsU0FBUztJQUM1QixPQUFPLEVBQUUsS0FBSztJQUNkLE9BQU8sRUFBRSxFQUFFLEdBQUcsSUFBSTtJQUNsQixVQUFVLEVBQUUsQ0FBQztJQUNiLFVBQVUsRUFBRSxDQUFDO0lBQ2IsaUJBQWlCLEVBQUUsS0FBSztJQUN4QixlQUFlLEVBQUUsQ0FBQztJQUNsQixTQUFTLEVBQUUsU0FBUztDQUN2QixDQUFDO0FBY0YsTUFBTSwyQkFBMkIsR0FBRyxHQUFHLENBQUM7QUFDeEMsTUFBTSx1QkFBdUIsR0FBRyxHQUFHLENBQUM7QUFDcEMsTUFBTSx3QkFBd0IsR0FBRyxFQUFFLENBQUM7QUFFcEM7SUFBQSxNQUFxQixPQUF5QyxTQUFRLHFCQUFZO1FBNEM5RSxZQUFvQixPQUErQjtZQUMvQyxLQUFLLEVBQUUsQ0FBQztZQXRDSixzQkFBaUIsR0FBMkIsSUFBSSxDQUFDO1lBQ2pELFlBQU8sR0FBa0MsRUFBRSxDQUFDO1lBQzVDLGlCQUFZLEdBQWtDLEVBQUUsQ0FBQztZQUNqRCxnQkFBVyxHQUFrQyxFQUFFLENBQUM7WUFDaEQsb0JBQWUsR0FBRyxDQUFDLENBQUM7WUFF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